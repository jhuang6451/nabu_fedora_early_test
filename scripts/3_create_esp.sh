#!/bin/bash

# ==============================================================================
# 3_create_esp.sh (v1.3 - Robust Chroot Invocation)
#
# 功能:
#   1. 创建一个 FAT32 格式的 ESP (EFI System Partition) 镜像文件。
#   2. 只读挂载一个预先存在的 Fedora rootfs 镜像。
#   3. 通过版本排序，可靠地检测 rootfs 中最新的内核版本。
#   4. 使用 dracut 在 chroot 环境中创建一个统一内核镜像 (UKI)。
#   5. 将生成的 UKI 放入 ESP 镜像中。
#   6. 确保在脚本执行完毕或失败时，所有挂载点和临时文件都被清理。
#
# 作者: Your Name (Generated by an expert AI)
# 版本: 1.3.0
# ==============================================================================

# --- 脚本健壮性设置 ---
set -e
set -u
set -o pipefail

# --- 变量定义 ---
echo "INFO: Initializing variables..."
ESP_NAME="esp.img"
ESP_SIZE_MB=512
ROOTFS_NAME="fedora-42-nabu-rootfs.img"
UKI_OUTPUT_NAME="fedora.efi" # 最终生成的EFI文件名

# 使用 mktemp 创建唯一的临时挂载点，避免冲突
ESP_MNT_POINT=$(mktemp -d)
ROOTFS_MNT_POINT=$(mktemp -d)

# --- 清理函数 (Trap) ---
cleanup() {
    echo "INFO: Performing cleanup..."
    # 使用 umount -l 在 CI/自动化环境中更稳健
    umount -l "${ROOTFS_MNT_POINT}/boot/efi" 2>/dev/null || true
    umount -l "$ESP_MNT_POINT" 2>/dev/null || true
    umount -l "$ROOTFS_MNT_POINT" 2>/dev/null || true

    # 删除临时创建的挂载点目录
    rmdir "$ESP_MNT_POINT" 2>/dev/null || true
    rmdir "$ROOTFS_MNT_POINT" 2>/dev/null || true
    echo "INFO: Cleanup complete."
}

# 设置 trap，在脚本退出 (EXIT) 时调用 cleanup 函数
trap cleanup EXIT

# --- 脚本主逻辑 ---

# 1. 检查依赖文件是否存在
if [ ! -f "$ROOTFS_NAME" ]; then
    echo "ERROR: Rootfs image '$ROOTFS_NAME' not found!"
    exit 1
fi

# 2. 挂载 Rootfs 镜像 (只读)
echo "INFO: Mounting rootfs image '$ROOTFS_NAME' (read-only)..."
mount -o loop,ro "$ROOTFS_NAME" "$ROOTFS_MNT_POINT"
echo "INFO: Rootfs mounted at '$ROOTFS_MNT_POINT'."

# 3. 动态检测内核版本 (已修正为 v1.4 的稳健方法)
echo "INFO: Detecting kernel version from rootfs..."
# 使用 find... | sort ... | head ... 配合命令替换来获取最新内核的文件名。
# 这是最直接且兼容性好的方法，因为内核文件名不包含换行符。
# -maxdepth 1 确保只在 /boot 目录下查找，不进入子目录。
# -printf "%f\n" 只打印不带路径的文件名，更干净。
VMLINUZ_FILENAME=$(find "$ROOTFS_MNT_POINT/boot/" -maxdepth 1 -name "vmlinuz-*" -not -name "*rescue*" -printf "%f\n" | sort -rV | head -n1)

if [ -z "$KERNEL_VMLINUZ_REL_PATH" ]; then
    echo "ERROR: Could not find any 'vmlinuz-*' kernel image (excluding rescue) in '$ROOTFS_MNT_POINT/boot/'."
    exit 1
fi

KERNEL_VERSION=${KERNEL_VMLINUZ_REL_PATH#vmlinuz-}
echo "INFO: Detected kernel version: $KERNEL_VERSION"

# 4. 创建并挂载 ESP 镜像
echo "INFO: Creating ESP image '$ESP_NAME' with size ${ESP_SIZE_MB}MB..."
fallocate -l "${ESP_SIZE_MB}M" "$ESP_NAME"
mkfs.vfat -F 32 -n "ESP" "$ESP_NAME"

echo "INFO: Mounting ESP image..."
mount -o loop "$ESP_NAME" "$ESP_MNT_POINT"
echo "INFO: ESP mounted at '$ESP_MNT_POINT'."

# 5. 生成统一内核镜像 (UKI)
echo "INFO: Preparing chroot environment for UKI generation..."

mkdir -p "${ROOTFS_MNT_POINT}/boot/efi"
mount --bind "$ESP_MNT_POINT" "${ROOTFS_MNT_POINT}/boot/efi"
echo "INFO: Bind mounted ESP to '${ROOTFS_MNT_POINT}/boot/efi'."

echo "INFO: Generating Unified Kernel Image (UKI) using dracut inside chroot..."

CHROOT_STUB="/usr/lib/systemd/boot/efi/linuxaarch64.efi.stub"
CHROOT_DTB_PATH="/usr/lib/modules/${KERNEL_VERSION}/dtb/qcom/sm8150-xiaomi-nabu.dtb"
CHROOT_OUTPUT_UKI="/boot/efi/EFI/fedora/${UKI_OUTPUT_NAME}"
CHROOT_CMDLINE="root=LABEL=fedora_root rw quiet"

# 再次检查 DTB 文件是否存在，这是一个好习惯
if [ ! -f "${ROOTFS_MNT_POINT}/${CHROOT_DTB_PATH}" ]; then
    echo "ERROR: DTB file not found at expected path: ${ROOTFS_MNT_POINT}/${CHROOT_DTB_PATH}"
    exit 1
fi

mkdir -p "${ROOTFS_MNT_POINT}/$(dirname "$CHROOT_OUTPUT_UKI")"

# --- 关键修正点 ---
# 直接调用 chroot <path> <command> <arg1> <arg2>...
# 这种方式避免了复杂的 shell 嵌套和引用问题，更加稳健。
echo "INFO (chroot): Running dracut command directly..."
chroot "$ROOTFS_MNT_POINT" /usr/bin/dracut \
    --force \
    --kver "$KERNEL_VERSION" \
    --uefi \
    --uefi-stub "$CHROOT_STUB" \
    --kernel-cmdline "$CHROOT_CMDLINE" \
    --uefi-dtb "$CHROOT_DTB_PATH" \
    "$CHROOT_OUTPUT_UKI"

echo "INFO: UKI generation complete. The file is located at '$ESP_MNT_POINT/EFI/fedora/$UKI_OUTPUT_NAME'."

# 6. 成功完成
echo "SUCCESS: ESP image '$ESP_NAME' with UKI has been created successfully."
exit 0