#!/bin/bash

# ==============================================================================
# 3_create_esp.sh (v2.0 - Correct Method using dracut + ukify)
#
# 功能:
#   1. 以读写模式挂载 Fedora rootfs 镜像。
#   2. 可靠地检测最新的内核版本。
#   3. [阶段1] 在 chroot 环境中使用 dracut 生成一个标准的 initramfs 镜像。
#   4. [阶段2] 使用 systemd-ukify 将内核、initramfs、DTB 和命令行打包成
#      一个统一内核镜像 (UKI)。
#   5. 将生成的 UKI 放入 ESP 镜像中。
#   6. 确保所有挂载点和临时文件都被清理。
#
# 作者: Your Name (Generated by an expert AI)
# 版本: 2.0.0
# ==============================================================================

# --- 脚本健壮性设置 ---
set -e
set -u
set -o pipefail

sudo dnf install -y systemd-ukify

# --- 前置依赖检查 ---
if ! command -v ukify &> /dev/null; then
    echo "ERROR: 'ukify' command not found on the host system."
    echo "Please install it first. On Fedora: sudo dnf install systemd-ukify"
    exit 1
fi

# --- 变量定义 ---
echo "INFO: Initializing variables..."
ESP_NAME="esp.img"
ESP_SIZE_MB=512
ROOTFS_NAME="fedora-42-nabu-rootfs.img"
UKI_OUTPUT_NAME="fedora.efi"

# 临时文件
INITRAMFS_TMP_FILE="" # 使用 mktemp 在后面安全地创建
cleanup() {
    echo "INFO: Performing cleanup..."
    if [ -n "$INITRAMFS_TMP_FILE" ] && [ -f "$INITRAMFS_TMP_FILE" ]; then
        rm -f "$INITRAMFS_TMP_FILE"
    fi
    # umount -l is more robust in CI environments
    umount -l "${ROOTFS_MNT_POINT}/boot/efi" 2>/dev/null || true
    umount -l "$ESP_MNT_POINT" 2>/dev/null || true
    umount -l "$ROOTFS_MNT_POINT" 2>/dev/null || true
    rmdir "$ESP_MNT_POINT" 2>/dev/null || true
    rmdir "$ROOTFS_MNT_POINT" 2>/dev/null || true
    echo "INFO: Cleanup complete."
}

# 使用 mktemp 创建唯一的临时挂载点和文件
ESP_MNT_POINT=$(mktemp -d)
ROOTFS_MNT_POINT=$(mktemp -d)

# 设置 trap，在脚本退出 (EXIT) 时调用 cleanup 函数
trap cleanup EXIT

# --- 脚本主逻辑 ---

# 1. 挂载 Rootfs 镜像 (读写)
echo "INFO: Mounting rootfs image '$ROOTFS_NAME' (read-write)..."
mount -o loop,rw "$ROOTFS_NAME" "$ROOTFS_MNT_POINT"
echo "INFO: Rootfs mounted at '$ROOTFS_MNT_POINT'."

# 2. 动态检测内核版本
echo "INFO: Detecting kernel version from rootfs..."
VMLINUZ_FILENAME=$(find "$ROOTFS_MNT_POINT/boot/" -maxdepth 1 -name "vmlinuz-*" -not -name "*rescue*" -printf "%f\n" | sort -rV | head -n1)
if [ -z "$VMLINUZ_FILENAME" ]; then
    echo "ERROR: Could not find any 'vmlinuz-*' kernel image in '$ROOTFS_MNT_POINT/boot/'."
    exit 1
fi
KERNEL_VERSION=${VMLINUZ_FILENAME#vmlinuz-}
echo "INFO: Detected kernel version: $KERNEL_VERSION"

# 3. [阶段 1] 使用 dracut 生成 Initramfs
echo "INFO: [Phase 1] Generating initramfs using dracut inside chroot..."
INITRAMFS_TMP_FILE=$(mktemp) # 创建一个安全的临时文件来存放initramfs
# chroot 内部的目标路径
CHROOT_INITRAMFS_OUTPUT="/tmp/initramfs-for-uki.img"

# 我们需要在 chroot 内部运行 dracut，以便它能访问 rootfs 中的所有模块和配置
chroot "$ROOTFS_MNT_POINT" /usr/bin/dracut \
    --force \
    --kver "$KERNEL_VERSION" \
    "$CHROOT_INITRAMFS_OUTPUT"

# 将 chroot 内生成的 initramfs 复制出来到我们的临时文件中
cp "${ROOTFS_MNT_POINT}${CHROOT_INITRAMFS_OUTPUT}" "$INITRAMFS_TMP_FILE"
rm "${ROOTFS_MNT_POINT}${CHROOT_INITRAMFS_OUTPUT}" # 清理 chroot 内部的临时文件
echo "INFO: Initramfs generated and stored at '$INITRAMFS_TMP_FILE'."

# 4. 创建并挂载 ESP 镜像
echo "INFO: Creating ESP image '$ESP_NAME' with size ${ESP_SIZE_MB}MB..."
fallocate -l "${ESP_SIZE_MB}M" "$ESP_NAME"
mkfs.vfat -F 32 -n "ESP" "$ESP_NAME"
mount -o loop "$ESP_NAME" "$ESP_MNT_POINT"
echo "INFO: ESP mounted at '$ESP_MNT_POINT'."

# 5. [阶段 2] 使用 ukify 构建最终的 UKI
echo "INFO: [Phase 2] Building final UKI using ukify..."

# 定义所有组件的路径
KERNEL_PATH="${ROOTFS_MNT_POINT}/boot/${VMLINUZ_FILENAME}"
DTB_PATH="${ROOTFS_MNT_POINT}/usr/lib/modules/${KERNEL_VERSION}/dtb/qcom/sm8150-xiaomi-nabu.dtb"
CMDLINE="root=LABEL=fedora_root rw quiet"
OUTPUT_UKI_PATH="${ESP_MNT_POINT}/EFI/fedora/${UKI_OUTPUT_NAME}"

# 确保输出目录存在
mkdir -p "$(dirname "$OUTPUT_UKI_PATH")"

# 检查所有文件是否存在，避免 ukify 报错
if [ ! -f "$KERNEL_PATH" ]; then echo "ERROR: Kernel file not found: $KERNEL_PATH"; exit 1; fi
if [ ! -f "$INITRAMFS_TMP_FILE" ]; then echo "ERROR: Initramfs file not found: $INITRAMFS_TMP_FILE"; exit 1; fi
if [ ! -f "$DTB_PATH" ]; then echo "ERROR: DTB file not found: $DTB_PATH"; exit 1; fi

ukify build \
    --linux="$KERNEL_PATH" \
    --initrd="$INITRAMFS_TMP_FILE" \
    --cmdline="$CMDLINE" \
    --devicetree="$DTB_PATH" \
    --output="$OUTPUT_UKI_PATH"

echo "INFO: UKI generation complete. The file is located at '$OUTPUT_UKI_PATH'."

# 6. 成功完成
echo "SUCCESS: ESP image '$ESP_NAME' with UKI has been created successfully."
exit 0